---
layout: post
title: "Breakout: Building A Cross-Platform Game in .NET MAUI with DrawnUI and Hot Preview"
date: 2024-07-15 12:00:00 +0000
categories: [MAUI, DrawnUI]
tags: [drawnui, skiasharp, dotnetmaui, game]    
description: .NET MAUI app completely drawn on a Skia canvas and its rendering engine.
image: /assets/img/ceojuly.jpg
---

> This article has [a second part](todo) about using [Hot Preview](https://github.com/BretJohnson/hot-preview) when desiging an app. This incredible technology shrinks tremendously the time we spend, providing with the possibility to instantly preview screens/controls/states of your application.

When working with .NET MAUI we are so used to making business apps that making a game can become a dream to fulfill.  

SCREENSHOT

But what tools to use? Should I place sprites inside a `Grid` and use translation for positionning them?  
If you've already been looking at how to escape from a predefined set of controls to a "draw what you want" concept you might already have tried [SkiaSharp](https://github.com/mono/SkiaSharp), that awesome library that exposes the [Skia](https://skia.org/) cross-platform rendering library to the .NET world.  

As awesome as it is, at some point I personnaly couldn't visualize the end result of all the "draw path, close path, draw surface" etc. 
If i had to draw on a game canvas it would be great to use something more abstract.   
The ideal would be to use a familiar layout system with `LayoutOptions` known by heart, to arrange controls that would draw what I want, just changing bindable properties. 

When looking at the game screenshot above you might have wondered "are those SVG or something, or they draw images for bricks"?  
Well, not at all:

```csharp
public class BrickSprite : SkiaShape, IWithHitBox, IReusableSprite
{
    public static BrickSprite Create()
    {
        return new BrickSprite
        {
            UseCache = SkiaCacheType.Operations,
            BackgroundColor = Colors.Red,
            CornerRadius = 6,
            WidthRequest = 50,
            HeightRequest = 24,
            StrokeColor = Colors.White,
            StrokeWidth = 2,
            BevelType = BevelType.Bevel,
            Bevel = new SkiaBevel()
            {
                Depth = 4,
                LightColor = Colors.White,
                ShadowColor = Color.Parse("#333333"),
                Opacity = 0.33
            },
            ZIndex = 4
        };
    }
...
}
```

So that's our brick, already feels better seeing `WidthRequest` and other properties, and this suggests it could maybe even be placed inside a layout with some manual offsets like "TranslationX" or something.
Not only this, it looks like this all is on points and would be scaled to any display size.

### Controls As Sprites

Using the [DrawnUI]() NuGet I can place drawn custom controls inside a hardware-accelerated canvas with a familiar WPF-like layout system and draw text, shapes, shadows and other effects by just setting bindable properties, without really caring about how this is all is drawn with Skia.   
Inside a MAUI-like layout experience we use intuitive concepts like `SkiaLabel`, `SkiaShape`, `SkiaLayout` and more. 

Now every single sprite in the game is basically just a styled control:

```csharp
public class BallSprite : SkiaShape
{
   public BallSprite(): SkiaShape
   {
   	UseCache = SkiaCacheType.GPU;
   	HeightRequest = 15;
   	HorizontalOptions = LayoutOptions.Center;
   	VerticalOptions = LayoutOptions.End;
	Type = ShapeType.Circle;
	StrokeColor = Colors.White;
	StrokeWidth = 2;
	LockRatio = 1;
	BackgroundColor = Colors.Aqua;
	SpeedRatio = 1;
	IsActive = true;
	BevelType = BevelType.Bevel;
	Bevel = new SkiaBevel()
	{
		Depth = 4,
		LightColor = Colors.White,
		ShadowColor = Color.Parse("#333333"),
		Opacity = 0.33
	};
   }
   ...
}
```

Controls can be placed inside layouts similar to vertical stack, horizontal stack, absolute (think MAUI Grid with 1 col/row) etc.
We can apply many types of transfroms here and obviously we could move objects with `TranslationX` and `TranslationY`.

This is what was done on the first game etude, made with DrawnUi for .NET MAUI: The SpaceShooter.

SCREENSHOT

So in a usual scenario you could do a simple `Ball.TranslationX = positionOffsetX` to move horizontally.  

But in this new etude I was using another custom set of displacement properties `Left` and `Top`.  
Why not usual translations: while optimizing felt better to avoid applying a transformation matrix.
Instead when a control is cached we can use `Left` and `Top` just to offset control's cache, 
no matrix transforms involved.

## The Game Loop

The game logic is just... a normal game logic. If you've written games in WPF, WinForms, 
or any other framework, you'll feel right at home.
We are using a helper from DrawnUI offering a game loop helper so we use 
```csharp
public override void GameLoop(float deltaSeconds)
```
to place our frame processing code there. We get the elapsed time after the previous frame is fractonal seconds.

Inside we:
* process input
* detect collisions
* remove queued sprites from game field
* add new queued sprites to game field
* change game state

..to be continued
 

### Hot Preview: The Game Changer for Development

This changed everything! ðŸ”¥
Imagine being able to:
- Preview different game states instantly
- Switch between levels without recompiling
- Test different sprite configurations on the fly
- Preview the game in different languages
- Adjust AI difficulty in real-time

The development experience becomes incredibly fluid when you can see your changes instantly instead of navigating through the app or recompiling.

### Developing on Windows

I was developing on Windows for faster compilation and more fluent HotReload experience.   
When working with MAUI business apps the workflow is similar: even if the app is not designed to run on Windows it's saves **a lot** of time to be working on it's Windows-Mock version and then adjust for mobile.

### .NET HotReload

This game wasn't really using XAML for UI and .NET HotReload worked was very useful for reloading the game while changing code logic instead of recompiling everything. XAML HotReload is great, but when it comes to changing the engine logic on the fly it might be better to use code-behind HotReload.
The page we were using was a `BasePageReloadable`, a subclassed `ContentPage` that has it's `Build` method triggered when HotReload hits.  

If you find `HotReload` requiring you to constantly rebuild the app, make you clear `bin/obj` folders: consider temporarily changing project to use just one framework instead of multiple. This comes from how HotReload currently works.

Another "by the way" tip to speed up your compilations with Visual Studio: if it starts to freeze during compilations or "just like that", run `taskkill /F /im msbuild.exe` in terminal. I keep it open at all times.

## Performance Tricks â€“ Object Pooling Made Simple

We implemented object pooling without any game engine magic. 
Here's the thing when you're destroying and creating hundreds of bricks, balls, and powerups, garbage collection becomes your enemy.

```csharp
private ReusableSpritePool<BrickSprite> BricksPool = new(MAX_BRICKS);
private ReusableSpritePool<PowerUpSprite> PowerupsPool = new(MAX_POWERUPS_IN_POOL);
private ReusableSpritePool<BulletSprite> PaddleBulletsPool = new(MAX_BULLETS_IN_POOL);
```

When a brick gets hit:
```csharp
void RemoveBrick(BrickSprite brick)
{
    BricksLeftToBreak -= 1;
    RemoveReusable(brick); // Goes back to pool, not garbage
}
```

Just like that  60fps on mobile with zero garbage collection hiccups. No special game engine required, just good old C# engineering practices.

## The Development Experience

What really was nice as i didn't have to use any "game engine scripting language" or "go c++" whatever, jsut stayed inside the comfort zone of C# and .NET MAUI.

...



## Looking Forward

This project is left with a lot of further possibilities. 

It demonstrates what we can achieve in .NET MAUI using abstractional controls and a familiar layout system.  
Think data visualizations, interactive diagrams, custom controls, or any scenario where you need to go beyond standard UI controls 
but don't want to dive deep into low-level graphics programming.

DrawnUI gives you that sweet spot  the performance and flexibility of SkiaSharp with the development experience of MAUI. You're not changing how you think about UI development, you're just removing the performance ceiling.

## Try It Yourself

The complete source code is available, and honestly, I'd love to hear what you think. 
Whether you're curious about game development, interested in pushing MAUI boundaries, 
or just want to see what DrawnUI can do, give it a spin.

What would you build with this stack? Please let me know  I'm always curious to see where other developers take these tools! 

---

*The game supports 12 levels, 9 languages, AI opponents, and even has a destroyer mode where you can shoot at bricks. But the real achievement? Proving that sometimes the best way to explore a framework's capabilities is to use it for something it wasn't explicitly designed for.*


## Final Words

Creating totally drawn NET MAUI apps remains in an experimental state as of today, and it could benefit from a lot more work
to make it a well supported way to develop MAUI apps. At the same time I believe this is a very interesting challenge for all of us.

I would greatly appreciate your feedback, especially on what do you think of this approach and what spots in your apps would be most useful to use drawn controls.
There is a related [thread on Reddit](https://www.reddit.com/r/dotnetMAUI/comments/1e3c2yl/published_maui_app_totally_drawn_with_skiasharp/), where I invite you to post any of your thoughts or questions.
Would you have any specific technical questions about using DrawnUI please feel free to use [Discussions](https://github.com/taublast/DrawnUi.Maui/discussions).

The [DrawnUI for .NET MAUI](https://github.com/taublast/DrawnUi.Maui) repository contains most of the reference links used in this article.  

<style>

.video-container {
  position: relative;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
  max-width: 100%;
  background: #000;
  margin-bottom: 1em;
}

.video-container iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.video-container-github {
    min-height: 200px;
    background: #000;
    margin-bottom: 1em;
}

.video-container-github video {
  width: 100%;
  height: 100%;
}

</style>

<!-- Place this tag in your head or just before your close body tag. -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

